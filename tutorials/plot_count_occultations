#!/usr/bin/env python3

#  Import python standard modules.

import os
import re
import json

#  Import installed modules.

import numpy as np
import matplotlib.cm as cm
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator


#  Matplotlib default settings.

axeslinewidth = 0.5
plt.rcParams.update( {
  'font.family': "Times New Roman",
  'font.size': 8,
  'font.weight': "normal",
  'text.usetex': False,
  'xtick.major.width': axeslinewidth,
  'xtick.minor.width': axeslinewidth,
  'ytick.major.width': axeslinewidth,
  'ytick.minor.width': axeslinewidth,
  'axes.linewidth': axeslinewidth } )

#  Intermediate files: mission color table.

colors_json_file = "color_table_by_mission.json"


def merge_jsonfiles( jsonfiles, output_jsonfile=None ):
    """Merge together the contents of multiple json files generated by
    count_occultations and return the contents of the merge. Write the
    merged contents to output_jsonfile if a filename is given."""

    #  Read the data.

    alldata_tmp = []
    for jsonfile in jsonfiles:
        with open( jsonfile, 'r' ) as fp:
            alldata_tmp += json.load( fp )

    #  Sort the data.

    yearmonths = [ f"{rec['year']:04d}-{rec['month']:02d}" for rec in alldata_tmp ]
    yearmonths_sorted = sorted( yearmonths )

    alldata = []
    for yearmonth in yearmonths_sorted:
        irec = yearmonths.index( yearmonth )
        alldata.append( alldata_tmp[irec] )

    #  Create a list of missions. 

    missions = set()
    for rec in alldata: 
        missions = missions.union( rec['noccs'].keys() )
    missions = list( missions )

    #  Be certain that every record in alldata has a key for every mission. 

    for rec in alldata: 
        recmissions = rec['noccs'].keys()
        for mission in missions: 
            if mission not in recmissions: 
                rec['noccs'].update( { mission: 0 } )

    #  Write to output if requested.

    if output_jsonfile is not None:
        with open( output_jsonfile, 'w' ) as e:
            json.dump( alldata, e )

    #  Done.

    return alldata


################################################################################
#  Methods.
################################################################################


def occultation_count_figure( alldata, epsfile, yticks=np.arange(0,5001,1000), yminor=200 ):
    """Plot of timeseries stackplot of the counts of occultations per day by
    mission with monthly resolution. Save encapsulated postscript file to
    epsfile. yticks is a numpy array of the major y tick marks, and yminor
    is the interval for minor ticks on the y axis."""

    #  Find the start dates of counts for each mission.

    missions = list( alldata[0]['noccs'].keys() )
    start_months = [ None for m in missions ]

    for rec in alldata:
        for im, m in enumerate( missions ):
            if start_months[im] is None and rec['noccs'][m] != 0:
                start_months[im] = rec['year'] + ( rec['month'] - 0.5 ) / 12.0

    #  Eliminate missions without data.

    smissions, sstarts = [], []
    for i, m in enumerate( missions ):
        if start_months[i] is not None:
            smissions.append( m )
            sstarts.append( start_months[i] )

    #  Sort start months.

    isort = np.argsort( sstarts )
    missions = []
    for i in isort:
        missions.append( smissions[i] )

    nmissions = isort.size

    #  Now resort the data.

    counts = np.zeros( (nmissions, len(alldata)), dtype='f' )
    times = np.array( [ rec['year'] + ( rec['month'] - 0.5 ) / 12.0 for rec in alldata ] )

    for irec, rec in enumerate( alldata ):
        for imission, mission in enumerate( missions ):
            counts[imission,irec] = rec['noccs'][mission]

    #  Normalize counts by days in each month.

    ndays = np.array( [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ], dtype='f' )
    for i, rec in enumerate( alldata ):
        imonth = rec['month'] - 1
        counts[:,i] /= ndays[imonth]

    #  Maximum number of occultations per month.

    maxcount = counts.sum(axis=0).max()

    #  Now do the stack plot.

    fig = plt.figure( figsize=[6,3] )
    ax = fig.add_axes( [ 0.12, 0.15, 0.86, 0.81 ] )

    #  x axis.

    ax.set_xlim( int( times[0] ), int( times[-1] ) + 1 )
    ax.set_xticks( np.arange( int(times[0]), times[-1]+1/12.0, 5 ) )
    ax.set_xticklabels( ax.get_xticks().astype('i'), rotation=-60, fontsize="large" )
    ax.xaxis.set_minor_locator( MultipleLocator( 1.0 ) )

    #  y axis.

    ax.set_ylabel( 'Mean daily counts', fontsize="large" )
    ax.set_ylim( 0, yticks.max() )
    ax.set_yticks( yticks )
    ax.set_yticklabels( ax.get_yticks().astype('i'), fontsize="large" )
    ax.yaxis.set_minor_locator( MultipleLocator( yminor ) )

    #  Colors.

    cmap = cm.get_cmap('tab20')
    colors = [ cmap(i*0.05) for i in range(len(missions)) ]

    #  Now, stack plot.

    ps = ax.stackplot( times, counts, labels=missions, colors=colors )
    ax.legend( loc="upper left", ncol=2 )
    leg = ax.get_legend()

    #  Get colors.

    colormap = {}
    for im, m in enumerate(missions):
        colormap.update( { m: list( ps[im].get_facecolor()[0] ) } )

    #  Save colors for future use.

    with open( colors_json_file, 'w' ) as c:
        print( f"Writing mission colors to {colors_json_file}." )
        json.dump( colormap, c, indent="    " )

    #  Generate plot.

    print( f"Saving to {epsfile}." )
    plt.savefig( epsfile, format="eps" )

    return



#  Main program.

if __name__ == "__main__":

    import argparse

    # Defaults. 

    ytickdef_default = "0,5000,1000,200"
    output_default = "plot_count_occultations.eps"

    parser = argparse.ArgumentParser( description="Plot a timeseries of the number of " + \
            "occultations by mission." )

    parser.add_argument( "-o", dest="output", type=str, default=output_default, 
            help="The name of the output encapsulated postscript file. " + \
                    f"The default is {output_default}." )

    parser.add_argument( "--ytickdef", type=str, default=ytickdef_default, 
            help="Four numbers separated by commas containing (1) the minimum " + \
                    "y tick mark, (2) the maximum y tick mark, (3) the interval " + \
                    "between major tick marks, and (4) the interval between minor " + \
                    "tick marks. The default is " + ytickdef_default )

    parser.add_argument( "jsonfiles", metavar="jsonfile", type=str, nargs="+", 
            help="Path to a JSON file containing occultation counts" )

    args = parser.parse_args()

    #  Y tick definitions. 

    s = re.split( ",", args.ytickdef )
    yticks = np.arange( float( s[0] ), float( s[1] ) + 0.01, float( s[2] ) )
    yminor = float( s[3] )

    #  Read the data. 

    alldata = merge_jsonfiles( args.jsonfiles )

    #  Plot. 

    ret = occultation_count_figure( alldata, args.output, yticks=yticks, yminor=yminor )

    pass

